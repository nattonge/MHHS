```{r load libraries}
library(psych)
library(tidyverse)
library(apaTables)
library(tableone)
library(dplyr)
library(qualtRics)
library(kutils)
library(pmr)
library(readxl)
library(smacof)
library(PlackettLuce)
library(prefmod)
library(qvcalc)

```

# The Finch Examples
Before applying to our massive dataset, some notes on the method and interpretation of the results based on Finch's faculty survey data.
```{r Finch example}
Finch_supp_data <- read_excel("Finch_supp_data.xlsx")

faculty.survey<-Finch_supp_data

faculty.rankings<-data.frame(faculty.survey[,1:6])
faculty.rankings.agg<-rankagg(faculty.rankings) 
#Experience: 1=0-5, 2-6-10, 3=11-15, 4-16-20, 5=21+
#Degree: 1=BA/BS, 2=MA/MS, 3=Specialist, 4=PhD
faculty.rankings<-data.frame(faculty.survey[,1:6])
faculty.rankings.agg<-rankagg(faculty.rankings)
```

## Destat
Destat = descriptive statistics of the ranking data
The list generates three datafranes: mean.rank, pair, and mar. 
*Mean.rank* gives the $m_i$ (mean rank for that item). It takes into account all possible rankings of $t$ objects, rank score given to $i$ item by each rater, the observed frequency of ranking. Lower values of $m$ indicate that the number is more favored
*Pair* refers to the pairwise comparisons. Going rowwise, item 1 ranks ahead of item 2 11 times, ahead of item 3 13 times and so on. Diagonal is 0 and the matrix is not symmetric. This is useful for identifying the specific positioning of two items relative to each other. Row + column givesthe number of all possible rankings.
*Mar* is the marginals. Going down the $p$th column indicates the number of times that $n$-item is in the $p$th-column position. For example, for row 1, column 1, item 1 is in first 8 times or ranked first by 8 people. 

```{r example destat}
destat(faculty.rankings.agg)

```
From this example using the faculty ranking data, item 2 is most favored followed by item 3 then item 1 (ranked 3rd). 

#SMACOFF

In the joint configuration plot, there are two dimensions. Much like a factor analysis, the algorithm reduces the data (in this case, to two dimensions) and it is the job of the analyst to describe those dimentions based on what they seem to be doing.
The Shepard Diagram..

```{r smacof}
faculty.smacof <-smacofRect(faculty.survey[,1:6], itmax=1000) 
plot(faculty.smacof, joint=TRUE, plot.type="confplot", what="both")
plot(faculty.smacof, plot.type = "Shepard")
```
## Placket-Luce Model

## Multi-Dimensional Pref
Returns two dataframes. Item summarizes the distance of each item on the two dimensions. Ranking summarizs the dat for each rater and 
Displays a 2D plot of the position of both judges and items, regardless of if 3-dim is specified. The items are labeled with consecutive numbers 1, 2, ..., k while the judges are presented as vectors pointing from the origin to their most preferred items.

Notice how nothing points to 4 and 6
```{r finch mdpref}
mdpref(faculty.rankings.agg,rank.vector = T)
mdpref(faculty.rankings.agg,rank.vector = T,ndim=2)

```
#PlackettLuce analysis# 
PLM conducted first.
coef faculty.mod_mle is using the first item as the reference group. The coefficients reflect the order observed in descriptives but are now assignment a "worth" value. 
Salary and health care are significant and positive relative to contract (higher ranked and more valued). Travel budget was significantly less valued; the others were not significantly different.

With mean worth as the reference, salary, healthcare, were all significantly higher than average but workload and travel budget were significantly lower. 
```{r}
faculty.rankings2<-as.rankings(faculty.rankings) 
faculty.mod_mle <- PlackettLuce(faculty.rankings2, npseudo=0) 
coef(faculty.mod_mle)
coef(faculty.mod_mle, log=FALSE) #this will give the worth parameters summed to 1
summary(faculty.mod_mle) #CATEOGRY 1 WORTH IS THE REFERENCE
summary(faculty.mod_mle, ref="health_care") #MEAN WORTH IS THE REFERENCE with NULL

faculty.mod_mle.itempars<-itempar(faculty.mod_mle, vcov=TRUE) #corresponds to probabilities

#ITEM PROBABILITIES FOR TOP RANK# 
faculty.itempars<-itempar(faculty.mod_mle, ref= 1, log = TRUE, vcov=TRUE) 

attributes(faculty.itempars)
itempar(faculty.mod_mle, ref=1:6) 
faculty.itempars.probabilities<-itempar(faculty.mod_mle, ref= 1:6)

attributes(faculty.itempars.probabilities)
faculty.itempars.probabilities

```
Additional descriptions and code from: https://hturner.github.io/PlackettLuce/
```{r another visualization}
qv <- qvcalc(faculty.mod_mle.itempars)
plot(qv, ylab = "Worth (log)", main = NULL)
```

#PLACKETTLUCE TREE# 
The Finch paper isn't the most helpful for understanding the trees in case of a split but does give a nice example of when no splits can be identified. Number of terminal nodes returning 1 just gives a single graph with the most preferred item. For illustration of a split, the PlackettLuce Vignette gives a great example: `vignette("Overview", package = "PlackettLuce").` 
```{r plct}
faculty.n<-nrow(faculty.survey)
faculty.g<-group(faculty.rankings2, index = rep(seq_len(faculty.n), 1)) 
faculty.tree <- pltree(faculty.g ~ ., data = faculty.survey[c("grad","experience")], minsize = 0.05*41, maxdepth = 3) 
plot(faculty.tree)

```
#TEST FOR RANDOM MEAN
$Q = \frac{12n}{t(t+1)} \Sigma{^t_{j=1}} (m_i - \frac{t+1}{2})^2 $

$Q$ is the chi-sq test statistic
$t$ i number of rankings
$m_i$ is the mean rank
$n$ is the number of participants
$\frac{t+1}{2}$ is the mean under the null
```{r}
null_mean<-rep(3.5,6) 
A<-((12*41)/(6*(6+1))) 
chi<-A*sum((faculty.desc$mean.rank-null_mean)^2) 
chi
dchisq(chi,5)
```

#PHI COMPONENT AND WEIGHTED DISTANCE BASED MODEL# 
```{r phi}
faculty.phicom<-phicom(faculty.rankings.agg) 
faculty.wdbm<-wdbm(faculty.rankings.agg, dtype="foot") 
faculty.phicom@min 
faculty.wdbm@min 
faculty.phicom@coef
faculty.wdbm@coef
```

#PLACKETTLUCE MODEL WITH COVARIATES#

```{r plmc}
faculty.survey$grad<-ifelse(faculty.survey$degree>1,1,0) #binary for graduate degree
exp_plmc<-summary(rol(faculty.rankings2,faculty.survey$experience)) #faculty rankings 2 is the groupd rankings class of object. allows the rankings to be linked to covariates with group-specific values

#NAT - adding the p-values and z-scores
exp_plmc@coef %>% as.data.frame(.) %>% mutate(z_score=Estimate/`Std. Error`) %>% rowwise() %>% mutate(p_value=2*(pnorm(abs(z_score),lower.tail = FALSE)))

grad_plmc<-summary(rol(faculty.rankings2,faculty.survey$grad))
grad_plmc@coef %>% as.data.frame(.) %>% mutate(z_score=Estimate/`Std. Error`) %>% rowwise() %>% mutate(p_value=2*(pnorm(abs(z_score),lower.tail = FALSE)))


```